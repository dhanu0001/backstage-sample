import { createApiRef, createPlugin, createApiFactory, discoveryApiRef, configApiRef, createComponentExtension, useApi } from '@backstage/core-plugin-api';
import fetch from 'cross-fetch';
import React, { useCallback, useEffect, useState } from 'react';
import { makeStyles, createStyles, Box, Typography, Paper, Tooltip, Divider, Link, FormControl, InputLabel, Select, Input, MenuItem, Checkbox, ListItemText, IconButton, Menu, Grid, Avatar } from '@material-ui/core';
import Alert from '@material-ui/lab/Alert';
import { Progress, InfoCard } from '@backstage/core-components';
import { useEntity } from '@backstage/plugin-catalog-react';
import convert from 'xml-js';
import moment from 'moment';
import { v4 } from 'uuid';
import { useAsyncFn, useAsync, useLocalStorage } from 'react-use';
import parse, { attributesToProps, domToReact } from 'html-react-parser';
import sanitizeHtml from 'sanitize-html';
import MoreVertIcon from '@material-ui/icons/MoreVert';

const jiraApiRef = createApiRef({
  id: "plugin.jira.service"
});
const DEFAULT_PROXY_PATH = "/jira/api";
const DEFAULT_REST_API_VERSION = "latest";
const DONE_STATUS_CATEGORY = "Done";
class JiraAPI {
  constructor(options) {
    this.generateProjectUrl = (url) => new URL(url).origin + new URL(url).pathname.replace(/\/rest\/api\/.*$/g, "");
    this.convertToString = (arrayElement) => arrayElement.filter(Boolean).map((i) => `'${i}'`).join(",");
    this.discoveryApi = options.discoveryApi;
    const proxyPath = options.configApi.getOptionalString("jira.proxyPath");
    this.proxyPath = proxyPath != null ? proxyPath : DEFAULT_PROXY_PATH;
    const apiVersion = options.configApi.getOptionalNumber("jira.apiVersion");
    this.apiVersion = apiVersion ? apiVersion.toString() : DEFAULT_REST_API_VERSION;
    this.confluenceActivityFilter = options.configApi.getOptionalString("jira.confluenceActivityFilter");
  }
  async getUrls() {
    const proxyUrl = await this.discoveryApi.getBaseUrl("proxy");
    return {
      apiUrl: `${proxyUrl}${this.proxyPath}/rest/api/${this.apiVersion}/`,
      baseUrl: `${proxyUrl}${this.proxyPath}`
    };
  }
  async pagedIssueCountRequest(apiUrl, jql, startAt) {
    const data = {
      jql,
      maxResults: -1,
      fields: ["key", "issuetype"],
      startAt
    };
    const request = await fetch(`${apiUrl}search`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify(data)
    });
    if (!request.ok) {
      throw new Error(`failed to fetch data, status ${request.status}: ${request.statusText}`);
    }
    const response = await request.json();
    const lastElement = response.startAt + response.maxResults;
    return {
      issues: response.issues,
      next: response.total > lastElement ? lastElement : void 0
    };
  }
  async getIssueCountPaged({
    apiUrl,
    projectKey,
    component,
    statusesNames
  }) {
    const statusesString = this.convertToString(statusesNames);
    const jql = `project = "${projectKey}"
      ${statusesString ? `AND status in (${statusesString})` : ""}
      ${component ? `AND component = "${component}"` : ""}
      AND statuscategory not in ("Done")
    `;
    let startAt = 0;
    const issues = [];
    while (startAt !== void 0) {
      const res = await this.pagedIssueCountRequest(apiUrl, jql, startAt);
      startAt = res.next;
      issues.push(...res.issues);
    }
    return issues;
  }
  async getIssuesCountByType({
    apiUrl,
    projectKey,
    component,
    statusesNames,
    issueType,
    issueIcon
  }) {
    const statusesString = this.convertToString(statusesNames);
    const jql = `project = "${projectKey}"
      AND issuetype = "${issueType}"
      ${statusesString ? `AND status in (${statusesString})` : ""}
      ${component ? `AND component = "${component}"` : ""}
      AND statuscategory not in ("Done")
    `;
    const data = {
      jql,
      maxResults: 0
    };
    const request = await fetch(`${apiUrl}search`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify(data)
    });
    if (!request.ok) {
      throw new Error(`failed to fetch data, status ${request.status}: ${request.statusText}`);
    }
    const response = await request.json();
    return {
      total: response.total,
      name: issueType,
      iconUrl: issueIcon
    };
  }
  async getProjectDetails(projectKey, component, statusesNames) {
    const { apiUrl } = await this.getUrls();
    const request = await fetch(`${apiUrl}project/${projectKey}`, {
      headers: {
        "Content-Type": "application/json"
      }
    });
    if (!request.ok) {
      throw new Error(`failed to fetch data, status ${request.status}: ${request.statusText}`);
    }
    const project = await request.json();
    let issuesCounter = [];
    let ticketIds = [];
    if (!component) {
      const issuesTypes = project.issueTypes.map((status) => ({
        name: status.name,
        iconUrl: status.iconUrl
      }));
      const filteredIssues = issuesTypes.filter((el) => el.name !== "Sub-task");
      issuesCounter = await Promise.all(filteredIssues.map((issue) => {
        const issueType = issue.name;
        const issueIcon = issue.iconUrl;
        return this.getIssuesCountByType({
          apiUrl,
          projectKey,
          component,
          statusesNames,
          issueType,
          issueIcon
        });
      }));
    } else {
      const issuesTypes = project.issueTypes.map((status) => ({
        name: status.name,
        iconUrl: status.iconUrl,
        total: 0
      }));
      const foundIssues = await this.getIssueCountPaged({
        apiUrl,
        projectKey,
        component,
        statusesNames
      });
      issuesCounter = foundIssues.reduce((prev, curr) => {
        const name = curr.fields.issuetype.name;
        const idx = issuesTypes.findIndex((i) => i.name === name);
        if (idx !== -1) {
          issuesTypes[idx].total++;
        }
        return prev;
      }, issuesTypes).filter((el) => el.name !== "Sub-task");
      ticketIds = foundIssues.map((i) => i.key);
    }
    return {
      project: {
        name: project.name,
        iconUrl: project.avatarUrls["48x48"],
        type: project.projectTypeKey,
        url: this.generateProjectUrl(project.self)
      },
      issues: issuesCounter && issuesCounter.length ? issuesCounter.map((status) => ({
        ...status
      })) : [],
      ticketIds
    };
  }
  async getActivityStream(size, projectKey, componentName, ticketIds, isBearerAuth) {
    const { baseUrl } = await this.getUrls();
    let filterUrl = `streams=key+IS+${projectKey}`;
    if (componentName && ticketIds) {
      filterUrl += `&streams=issue-key+IS+${ticketIds.join("+")}`;
      filterUrl += this.confluenceActivityFilter ? `&${this.confluenceActivityFilter}=activity+IS+NOT+*` : "";
    }
    const request = await fetch(isBearerAuth ? `${baseUrl}/activity?maxResults=${size}&${filterUrl}` : `${baseUrl}/activity?maxResults=${size}&${filterUrl}&os_authType=basic`);
    if (!request.ok) {
      throw new Error(`failed to fetch data, status ${request.status}: ${request.statusText}`);
    }
    const activityStream = await request.text();
    return activityStream;
  }
  async getStatuses(projectKey) {
    const { apiUrl } = await this.getUrls();
    const request = await fetch(`${apiUrl}project/${projectKey}/statuses`, {
      headers: {
        "Content-Type": "application/json"
      }
    });
    if (!request.ok) {
      throw new Error(`failed to fetch data, status ${request.status}: ${request.statusText}`);
    }
    const statuses = await request.json();
    return [
      ...new Set(statuses.flatMap((status) => status.statuses).filter((status) => {
        var _a;
        return ((_a = status.statusCategory) == null ? void 0 : _a.name) !== DONE_STATUS_CATEGORY;
      }).map((it) => it.name).reduce((acc, val) => {
        acc.push(val);
        return acc;
      }, []))
    ];
  }
}

const jiraPlugin = createPlugin({
  id: "jira",
  apis: [
    createApiFactory({
      api: jiraApiRef,
      deps: { discoveryApi: discoveryApiRef, configApi: configApiRef },
      factory: ({ discoveryApi, configApi }) => {
        return new JiraAPI({
          discoveryApi,
          configApi
        });
      }
    })
  ]
});
const EntityJiraOverviewCard = jiraPlugin.provide(createComponentExtension({
  name: "EntityJiraOverviewCard",
  component: {
    lazy: () => import('./esm/index-2505f800.esm.js').then((m) => m.JiraCard)
  }
}));

const handleError = (error) => {
  var _a, _b;
  return Promise.reject({
    message: ((_b = (_a = error == null ? void 0 : error.response) == null ? void 0 : _a.data) == null ? void 0 : _b.errorMessages) && error.response.data.errorMessages[0].toString() || (error == null ? void 0 : error.message) || (error == null ? void 0 : error.request) || error.toString()
  });
};

const getPropertyValue = (entry, property) => {
  var _a;
  return (_a = entry[property]) == null ? void 0 : _a._text;
};
const getElapsedTime = (start) => moment(start).fromNow();
const decodeHtml = (html) => {
  const txt = document.createElement("textarea");
  txt.innerHTML = html;
  return txt.value;
};
const useActivityStream = (size, projectKey, componentName, ticketIds, isBearerAuth) => {
  const api = useApi(jiraApiRef);
  const getActivityStream = useCallback(async () => {
    try {
      const response = await api.getActivityStream(size, projectKey, componentName, ticketIds, isBearerAuth);
      const parsedData = JSON.parse(convert.xml2json(response, { compact: true, spaces: 2 }));
      const mappedData = parsedData.feed.entry.map((entry) => {
        var _a;
        const id = `urn:uuid:${v4()}`;
        const time = getPropertyValue(entry, "updated");
        const iconLink = (_a = entry.link) == null ? void 0 : _a.find((link) => link._attributes.rel === "http://streams.atlassian.com/syndication/icon");
        let icon;
        if (iconLink) {
          icon = {
            url: iconLink._attributes.href,
            title: iconLink._attributes.title
          };
        }
        return {
          id,
          time: {
            elapsed: getElapsedTime(time),
            value: new Date(time).toLocaleTimeString("en-US", {
              weekday: "long",
              year: "numeric",
              month: "long",
              day: "numeric"
            })
          },
          title: decodeHtml(getPropertyValue(entry, "title")),
          icon,
          summary: decodeHtml(getPropertyValue(entry, "summary") || ""),
          content: decodeHtml(getPropertyValue(entry, "content") || "")
        };
      });
      return mappedData;
    } catch (err) {
      return handleError(err);
    }
  }, [api, size, projectKey, componentName, ticketIds, isBearerAuth]);
  const [state, fetchActivityStream] = useAsyncFn(() => getActivityStream(), [size]);
  useEffect(() => {
    fetchActivityStream();
  }, [size, fetchActivityStream]);
  return {
    activitiesLoading: state.loading,
    activities: state.value,
    activitiesError: state.error
  };
};

const useProjectInfo = (projectKey, component, statusesNames) => {
  var _a, _b, _c;
  const api = useApi(jiraApiRef);
  const getProjectDetails = useCallback(async () => {
    try {
      setTimeout(() => document.activeElement.blur(), 0);
      return await api.getProjectDetails(projectKey, component, statusesNames);
    } catch (err) {
      return handleError(err);
    }
  }, [api, projectKey, component, statusesNames]);
  const [state, fetchProjectInfo] = useAsyncFn(() => getProjectDetails(), [statusesNames]);
  useEffect(() => {
    fetchProjectInfo();
  }, [statusesNames, fetchProjectInfo]);
  return {
    projectLoading: state.loading,
    project: (_a = state == null ? void 0 : state.value) == null ? void 0 : _a.project,
    issues: (_b = state == null ? void 0 : state.value) == null ? void 0 : _b.issues,
    ticketIds: (_c = state == null ? void 0 : state.value) == null ? void 0 : _c.ticketIds,
    projectError: state.error,
    fetchProjectInfo
  };
};

const useStatuses = (projectKey) => {
  const api = useApi(jiraApiRef);
  const getStatuses = useCallback(async () => {
    try {
      return await api.getStatuses(projectKey);
    } catch (err) {
      return handleError(err);
    }
  }, [api, projectKey]);
  const { loading, value, error } = useAsync(() => getStatuses(), []);
  return {
    statusesLoading: loading,
    statuses: value,
    statusesError: error
  };
};

const JIRA_PROJECT_KEY_ANNOTATION = "jira/project-key";
const JIRA_BEARER_TOKEN_ANNOTATION = "jira/token-type";
const JIRA_COMPONENT_ANNOTATION = "jira/component";
const useProjectEntity = (entity) => {
  var _a, _b, _c, _d, _e, _f;
  return {
    projectKey: (_b = (_a = entity.metadata) == null ? void 0 : _a.annotations) == null ? void 0 : _b[JIRA_PROJECT_KEY_ANNOTATION],
    component: (_d = (_c = entity.metadata) == null ? void 0 : _c.annotations) == null ? void 0 : _d[JIRA_COMPONENT_ANNOTATION],
    tokenType: (_f = (_e = entity.metadata) == null ? void 0 : _e.annotations) == null ? void 0 : _f[JIRA_BEARER_TOKEN_ANNOTATION]
  };
};

const useStyles$3 = makeStyles(() => createStyles({
  subtitles: {
    whiteSpace: "nowrap"
  }
}));
const Status = ({
  name,
  iconUrl
}) => {
  const classes = useStyles$3();
  return /* @__PURE__ */ React.createElement(Box, {
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    mb: 1
  }, /* @__PURE__ */ React.createElement("img", {
    src: iconUrl,
    alt: ""
  }), /* @__PURE__ */ React.createElement(Box, {
    ml: 1,
    className: classes.subtitles
  }, /* @__PURE__ */ React.createElement(Typography, {
    variant: "subtitle2"
  }, name)));
};

const useStyles$2 = makeStyles((theme) => createStyles({
  paper: {
    padding: theme.spacing(2),
    backgroundColor: theme.palette.type === "dark" ? "#333" : "#f6f8fa",
    color: theme.palette.text.primary,
    marginTop: theme.spacing(1),
    overflowY: "auto",
    maxHeight: "290px",
    "& a": {
      color: theme.palette.primary.main
    },
    "& hr": {
      backgroundColor: theme.palette.divider,
      margin: theme.spacing(1, 0)
    },
    "& blockquote": {
      background: theme.palette.type === "dark" ? "#424242" : "#e0f0ff",
      borderLeft: "1px solid #c2d9ef",
      color: theme.palette.text.primary,
      fontStyle: "normal",
      margin: theme.spacing(1, 0),
      overflowX: "auto",
      overflowY: "hidden",
      padding: theme.spacing(0, 1)
    },
    "& > :last-child > hr": {
      display: "none"
    },
    "&::-webkit-scrollbar-track": {
      backgroundColor: theme.palette.type === "dark" ? "#555" : "#F5F5F5",
      borderRadius: "5px"
    },
    "&::-webkit-scrollbar": {
      width: "5px",
      backgroundColor: theme.palette.type === "dark" ? "#555" : "#F5F5F5",
      borderRadius: "5px"
    },
    "&::-webkit-scrollbar-thumb": {
      border: `1px solid ${theme.palette.type === "dark" ? "#555" : "#F5F5F5"}`,
      backgroundColor: theme.palette.type === "dark" ? "#F5F5F5" : "#555",
      borderRadius: "4px"
    },
    "& span": {
      fontSize: "0.7rem"
    }
  },
  time: {
    lineHeight: 0,
    marginLeft: theme.spacing(1)
  },
  timeNoIcon: {
    lineHeight: 0,
    margin: "8px 0"
  },
  link: {
    cursor: "pointer"
  }
}));
const options = {
  replace: (node) => {
    if (!node)
      return null;
    if (node.name === "a") {
      const props = attributesToProps(node.attribs);
      return /* @__PURE__ */ React.createElement("a", {
        ...props,
        target: "_blank",
        rel: "noopener noreferrer"
      }, node.children && domToReact(node.children));
    }
    return null;
  }
};
const ActivityStream = ({
  projectKey,
  tokenType,
  componentName,
  ticketIds
}) => {
  const classes = useStyles$2();
  const [size, setSize] = useState(25);
  const [disableButton, setDisableButton] = useState(false);
  const isBearerAuth = (tokenType == null ? void 0 : tokenType.includes("Bearer")) ? true : false;
  const { activities, activitiesLoading, activitiesError } = useActivityStream(size, projectKey, componentName, ticketIds, isBearerAuth);
  const showMore = useCallback(() => {
    setSize(size + 10);
    if (activities && activities.length < size) {
      setDisableButton(true);
    }
  }, [size, activities]);
  if (activitiesError)
    return null;
  const filteredIssues = activities == null ? void 0 : activities.filter((entry) => {
    var _a;
    return !((_a = entry == null ? void 0 : entry.icon) == null ? void 0 : _a.title.includes("Sub-task"));
  });
  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(Typography, {
    variant: "subtitle1"
  }, "Activity stream"), /* @__PURE__ */ React.createElement(Paper, {
    className: classes.paper
  }, activitiesLoading ? /* @__PURE__ */ React.createElement(Progress, null) : null, filteredIssues ? /* @__PURE__ */ React.createElement(React.Fragment, null, filteredIssues.map((entry) => /* @__PURE__ */ React.createElement(Box, {
    key: entry.id
  }, parse(entry.title, options), /* @__PURE__ */ React.createElement(Box, null, parse(sanitizeHtml(entry.summary || entry.content || "", {
    disallowedTagsMode: "escape"
  }), options)), /* @__PURE__ */ React.createElement(Box, {
    display: "flex",
    alignItems: "center",
    mt: 1
  }, entry.icon ? /* @__PURE__ */ React.createElement(Tooltip, {
    title: entry.icon.title
  }, /* @__PURE__ */ React.createElement("img", {
    src: entry.icon.url,
    alt: entry.icon.title
  })) : null, /* @__PURE__ */ React.createElement(Tooltip, {
    title: entry.time.value
  }, /* @__PURE__ */ React.createElement(Typography, {
    variant: "caption",
    className: entry.icon ? classes.time : classes.timeNoIcon
  }, entry.time.elapsed))), /* @__PURE__ */ React.createElement(Divider, null))), /* @__PURE__ */ React.createElement(Box, {
    display: "flex",
    justifyContent: "center",
    pt: 1
  }, disableButton ? "No more activities" : /* @__PURE__ */ React.createElement(Link, {
    onClick: showMore,
    className: classes.link
  }, activitiesLoading ? "Loading.." : "Show more.."))) : null));
};

const useStyles$1 = makeStyles(() => createStyles({
  formControl: {
    minWidth: 150
  }
}));
const ITEM_HEIGHT = 48;
const ITEM_PADDING_TOP = 8;
const MenuProps = {
  PaperProps: {
    style: {
      maxHeight: ITEM_HEIGHT * 4.5 + ITEM_PADDING_TOP,
      width: 350
    }
  }
};
const Selectors = ({
  projectKey,
  statusesNames,
  setStatusesNames,
  fetchProjectInfo
}) => {
  const classes = useStyles$1();
  const { statuses, statusesLoading, statusesError } = useStatuses(projectKey);
  const handleStatusesChange = (event) => {
    setStatusesNames(event.target.value);
  };
  return !statusesLoading && !statusesError && statuses && statuses.length >= 2 ? /* @__PURE__ */ React.createElement(Box, {
    display: "flex",
    justifyContent: "flex-end"
  }, /* @__PURE__ */ React.createElement(FormControl, {
    className: classes.formControl
  }, /* @__PURE__ */ React.createElement(InputLabel, {
    id: "select-multiple-projects-statuses"
  }, "filter issue status"), /* @__PURE__ */ React.createElement(Select, {
    labelId: "select-statuses-label",
    id: "select-statuses",
    multiple: true,
    value: statusesNames,
    onChange: handleStatusesChange,
    input: /* @__PURE__ */ React.createElement(Input, null),
    renderValue: (selected) => selected.filter(Boolean).join(", "),
    MenuProps,
    onClose: fetchProjectInfo
  }, statuses.map((status) => /* @__PURE__ */ React.createElement(MenuItem, {
    key: status,
    value: status
  }, /* @__PURE__ */ React.createElement(Checkbox, {
    checked: statusesNames.indexOf(status) > -1
  }), /* @__PURE__ */ React.createElement(ListItemText, {
    primary: status
  })))))) : null;
};

const useEmptyIssueTypeFilter = (issueTypes) => {
  const [type, setType] = useLocalStorage("jira-plugin-issuetype-filter", "non-empty");
  return {
    issueTypes: type === "non-empty" ? issueTypes == null ? void 0 : issueTypes.filter((t) => t.total !== 0) : issueTypes,
    type,
    changeType: type === "non-empty" ? () => setType("all") : () => setType("non-empty")
  };
};

const useStyles = makeStyles((theme) => createStyles({
  infoCard: {
    marginBottom: theme.spacing(3),
    "& + .MuiAlert-root": {
      marginTop: theme.spacing(3)
    }
  },
  root: {
    flexGrow: 1,
    fontSize: "0.75rem",
    "& > * + *": {
      marginTop: theme.spacing(1)
    }
  }
}));
const CardProjectDetails = ({
  project,
  component
}) => /* @__PURE__ */ React.createElement(Box, {
  display: "inline-flex",
  alignItems: "center"
}, /* @__PURE__ */ React.createElement(Avatar, {
  alt: "",
  src: project.iconUrl
}), /* @__PURE__ */ React.createElement(Box, {
  ml: 1
}, project.name, " | ", project.type, component ? /* @__PURE__ */ React.createElement(Box, null, "component: ", component) : null));
const JiraCard = (_props) => {
  const { entity } = useEntity();
  const classes = useStyles();
  const { projectKey, component, tokenType } = useProjectEntity(entity);
  const [statusesNames, setStatusesNames] = useState([]);
  const {
    project,
    issues,
    ticketIds,
    projectLoading,
    projectError,
    fetchProjectInfo
  } = useProjectInfo(projectKey, component, statusesNames);
  const {
    issueTypes: displayIssues,
    type,
    changeType
  } = useEmptyIssueTypeFilter(issues);
  const [anchorEl, setAnchorEl] = React.useState(null);
  const handleClick = (event) => {
    setAnchorEl(event.currentTarget);
  };
  const handleClose = () => {
    setAnchorEl(null);
  };
  return /* @__PURE__ */ React.createElement(InfoCard, {
    className: classes.infoCard,
    title: "Jira",
    subheader: project && /* @__PURE__ */ React.createElement(Box, null, /* @__PURE__ */ React.createElement(CardProjectDetails, {
      project,
      component
    }), /* @__PURE__ */ React.createElement(Box, {
      display: "inline-flex",
      pl: 1
    }, /* @__PURE__ */ React.createElement(IconButton, {
      "aria-label": "more",
      "aria-controls": "long-menu",
      "aria-haspopup": "true",
      onClick: handleClick
    }, /* @__PURE__ */ React.createElement(MoreVertIcon, null)), /* @__PURE__ */ React.createElement(Menu, {
      id: "simple-menu",
      anchorEl,
      keepMounted: true,
      open: Boolean(anchorEl),
      onClose: handleClose
    }, /* @__PURE__ */ React.createElement(MenuItem, {
      onClick: changeType
    }, /* @__PURE__ */ React.createElement(Checkbox, {
      checked: type === "all"
    }), /* @__PURE__ */ React.createElement(React.Fragment, null, "Show empty issue types"))))),
    deepLink: {
      link: `${project == null ? void 0 : project.url}/browse/${projectKey}`,
      title: "Go to project",
      onClick: (e) => {
        e.preventDefault();
        window.open(`${project == null ? void 0 : project.url}/browse/${projectKey}`);
      }
    }
  }, projectLoading && !(project && issues) ? /* @__PURE__ */ React.createElement(Progress, null) : null, projectError ? /* @__PURE__ */ React.createElement(Alert, {
    severity: "error",
    className: classes.infoCard
  }, projectError.message) : null, project && issues ? /* @__PURE__ */ React.createElement("div", {
    className: classes.root
  }, /* @__PURE__ */ React.createElement(Selectors, {
    projectKey,
    statusesNames,
    setStatusesNames,
    fetchProjectInfo
  }), /* @__PURE__ */ React.createElement(Grid, {
    container: true,
    spacing: 3
  }, displayIssues == null ? void 0 : displayIssues.map((issueType) => /* @__PURE__ */ React.createElement(Grid, {
    item: true,
    xs: true,
    key: issueType.name
  }, /* @__PURE__ */ React.createElement(Box, {
    width: 100,
    display: "flex",
    flexDirection: "column",
    alignItems: "center",
    justifyContent: "center"
  }, /* @__PURE__ */ React.createElement(Status, {
    name: issueType.name,
    iconUrl: issueType.iconUrl
  }), /* @__PURE__ */ React.createElement(Typography, {
    variant: "h4"
  }, issueType.total))))), /* @__PURE__ */ React.createElement(Divider, null), /* @__PURE__ */ React.createElement(ActivityStream, {
    projectKey,
    tokenType,
    componentName: component,
    ticketIds
  })) : null);
};

const isJiraAvailable = (entity) => {
  var _a;
  return Boolean((_a = entity == null ? void 0 : entity.metadata.annotations) == null ? void 0 : _a[JIRA_PROJECT_KEY_ANNOTATION]);
};

export { EntityJiraOverviewCard, JiraCard, isJiraAvailable, isJiraAvailable as isPluginApplicableToEntity, jiraPlugin, jiraPlugin as plugin };
//# sourceMappingURL=index.esm.js.map
